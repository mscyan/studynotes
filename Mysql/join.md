#mysql中的join查询

连接查询分为内连接和外连接

在外连接中，可以指定一个表为驱动表，驱动表中的记录如果在查询结果中不存在匹配记录，则会将其余列以NULL填充，并包含在结果集中
left join - 左边的表为驱动表
right join - 右边的表为驱动表

注意 **where** 与 **on** 的区别
**Q**：如果在一个连接查询中，不想像上面一样将不存在匹配记录的记录填充NULL值并返回，该怎么操作？
**A**：可以将过滤条件放置在where条件语句中

on子句是专门应对驱动表的记录在被驱动表中无匹配记录时，需要填充结果集而提出的，如果不想这样返回空记录，则可以把过滤条件放在where子句中，但仅在外连接中起作用，
在内连接中on子句与where子句等效；

### 连接查询优化：
T1和T2做连接查询，数据量都是十万条记录以上，连接查询会先查询驱动表，然后获取匹配的结果集再和被驱动表进行连接匹配，等于是
驱动表 访问 1次
被驱动表 访问 n次（n为驱动表中符合条件的记录条数）
如果被驱动表有非常大的数据量，数据在内存中不能完全存放，那么就会发生预期n$*$m（m为单次查询被驱动表产生的IO次数）次的IO，这对一次查询来说是致命的，会导致总查询时间过大。所以，一个优化的方向是：减少访问被驱动表的次数；
mysql自带的一种方案：申请一块内存区域——join buffer，存放驱动表中的记录（可能存放一部分，可能全部存放），每查询一次被驱动表，都与join buffer中的记录进行匹配，这样可能的IO总次数为k$*$m（k为驱动表中符合条件的记录条数/join buffer中可以存放的记录条数），显著减少了IO总次数。这种方案称为Block Nested-loop join，即基于块的嵌套连接；