
### MySQL中的锁
1. 共享锁
事务需要读取一条记录时，需要获取该记录的共享锁（Shared Locks），简称**S锁**
2. 排他锁
事务要对一条记录进行修改时，需要获取该记录的排他锁（Exclusive Locks），简称**X锁**

+ 当Trx1事务获取了一条记录的S锁进行读取时，Trx2事务也想获取S锁读取该条记录，这是允许的。如果Trx2事务想对这条记录进行修改操作，即获取X锁，则Trx2事务的操作会被阻塞；
+ 当Trx1事务获取了一条记录的X锁进行修改操作时，不论Trx2事务想对这条记录做什么操作，Trx2都会被阻塞；

锁定读：
锁定读是为了应对一些操作想在读取记录时同时获取该记录的X锁，我们可以使用比较特殊的select语句来获取X锁：`select * from [table] .. for update`，这样的select语句就会获取到满足条件记录的X锁，达到禁止其他事务读这些记录的操作。

#### 锁的粒度
+ 行级锁
只对行记录加锁
+ 表级锁
对整张表加锁，表锁也包含S锁和X锁，互相排斥关系于行级锁相同


#### 意向锁
意向锁是为了需要加表锁时，避免检查是否有行级锁时要遍历而提出的，每当事务要加行级锁时，都需要在表级别上加一个意向锁，具体包括：
IS锁：Intension Shared Lock，即意向共享锁
IX锁：Intension Exclusive Lock，即意向排他锁
需要注意的是，意向锁和意向锁之间是不互斥的，因为就算是对同一条记录进行加锁，这两个事务也都需要在表级别添加IX/IS锁，因为意向锁仅仅是判断当前是否有行级锁占用，具体执行到行级别的事务，他们之间的互斥等待可以通过行级锁来保证互斥。