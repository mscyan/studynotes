---
title: 'JVM垃圾回收器'
output: pdf_document
---

# 垃圾回收（GC） 
垃圾回收是Java的一大特点，在c++中，我们需要管理内存，每个对象用完后都必须及时释放。但让人来直接管理内存，管理对象是很危险的，所以Java的设计者移除了指针和内存管理，这些工作由JVM来做，毕竟机器不会出错，不会有遗漏，GC（Garbage Collection）是一些高级语言都具有的，主要用于清除无用对象，回收内存空间，因为Java里不让人来管理内存了嘛，所以JVM需要来做，虽然我们不需要做这些事情了，但了解GC，为我们后续对系统的性能调优，问题排查，都会有一些帮助。（虽然自己没有实际调优经验，但也看过很多前辈通过查看JVM的一些日志，排查一些性能问题，并且通过这些数据，也可以分析出系统的瓶颈）

### 如何确定对象‘死亡’
+ 引用计数法
任何一个对象只要被引用一次，就自增该对象的引用计数器，当引用失效时，则自减1，当计数器为0时，则表明该对象可以被回收。但引用计数法解决不了循环引用的问题，所以Java的垃圾回收器并没有采用这种算法
+ 可达性分析
该算法通过从一系列GC Roots的对象开始搜索，当一个对象与GC Roots没有连通时，则该对象不可用。
**哪些对象是Root？**
1. 虚拟机栈中引用的对象
2. 本地方法栈中引用的对象
3. 方法区中静态属性引用的变量
4. 方法区中常量引用的对象

### 引用的类型
1. 强引用
垃圾回收器不会回收强引用，如果内存不足，会抛出OutOfMemoryError也不会清除强引用。强引用意味着不可缺少，一般我们编码中的引用都是强引用。
2. 软引用
空间足够时，垃圾回收器不会管软引用，但当内存空间不足了，就会回收这些软引用对象的内存。软引用意味着有用，但并不是必不可少。
3. 弱引用
弱引用比软引用更可有可无，一旦被垃圾回收器扫描到，就会回收。
4. 虚引用
虚引用任何时候都会被回收。


### 几种垃圾回收算法
+ 标记清除
该算法将垃圾回收分为两个阶段，即标记阶段和清除阶段。标记阶段主要是标记那些可达的对象，一次遍历后，不可达的对象就没有被标记，所以当进入第二阶段时，这些无用的可回收的空间就可以被回收了。但只要简单画个图就会发现，这样操作会**导致大量的碎片空间**，要么导致内存空间利用率低，要么需要花费时间整理，所以并不适用所有场景
+ 复制算法
复制算法的逻辑比较简单，将内存空间分为两部分，一次只用其中之一，当该部分快满时，将可达对象（即不可回收对象）复制到另一空间，然后回收原来空间的内存，这样效率较高，但这是一种**空间换时间**的思想，那么浪费的必然是内存空间了，所以实际也并不能适用所有场景。复制算法主要被适用在Java垃圾回收器的新生代回收器中，新生代分为eden空间，from和to空间，from和to空间采用复制算法，虽然是空间换时间，但由于新生代占据的比例并不大，并且新生代gc的频率较高，所以总体上来说很划算。由此可见，复制算法适用于存活对象较少的场景，因为**如果存活对象很多，那么复制会耗费大量时间**。
+ 标记整理
标记清除算法中，我们直接标记可达对象，然后清除无用对象，会导致大量空间碎片，联系复制算法我们可以想到，标记之后再复制，让这些对象排列好，那么剩余的空间就是连续的了。标记整理就是这样操作的，既避免了碎片空间，也提升了内存使用率，但是我们要知道，标记整理应对大量对象存活的场景时，也是比较耗费时间的，所以标记整理也并不是适用所有场景。Java的垃圾回收器在老年代的垃圾回收器中采用了标记整理算法，因为老年代gc频率是比较小的，所以最终造成的影响并不是无法接受。
+ 分代收集
从以上几种垃圾回收算法中可以知道，每种算法并不适用所有的场景，要么耗费时间，要么降低内存利用率，所以JVM使用了分代收集的思想。比如HotSpot虚拟机中，将JVM内存空间分为新生代，老年代。对象在eden区诞生后，会根据不同情况进入survivor区或者老年代的空间（大对象进入老年代，小对象进入from区），在新生代采用复制算法，因为存活对象并不会很多，效率比较高。而大对象，或者年龄很大的对象可以认为基本会一直存活，所以直接放在老年代就好了，老年代采用标记整理算法。

### 垃圾回收器的类型
1. 按线程数分可分为串行垃圾回收期和并行垃圾回收器。串行回收器只使用一个线程进行回收，并行会开启多个线程。所以我们可以根据不同的硬件来选择不同的垃圾回收器来提供系统性能，比如单cpu机器如果设置并行回收的话反而会因为上下文切换等因素导致影响性能，而多核机器使用并行的话可以提供效率，减少GC的停顿时间
2. 按工作模式分，可分为独占式垃圾回收器和并发式垃圾回收器。并发式垃圾回收器与程序并发地执行工作，可以减少程序停顿时间，而独占式垃圾回收器会停止应用程序的运行，GC完毕后才唤醒应用程序。
3. 按碎片处理方式分，可分为压缩式垃圾回收器和非压缩式垃圾回收器，压缩式垃圾回收器会在回收完成后对存活区域进行压缩整理，而非压缩式垃圾回收器则不会做这些工作。
4. 按内存区间可分为新生代垃圾回收器和老年代垃圾回收器

### 衡量垃圾回收器的几种因素
*学习操作系统的时候，由于操作系统在对进程进行调度时，会采用各种进程调度算法，比如先来先服务，短作业优先，分时等，衡量一个调度算法的因素有周转时间，响应时间，平均周转时间等等。从上面的集中垃圾回收器的区别我们也可以得知，没有最优的调度算法，也没有最优的垃圾回收算法，不同的场景需要不同的垃圾回收器，所以我们需要了解不同的垃圾回收器的不同特点。*
+ 吞吐量：单位时间内，应用程序有效处理作业的数量，比如CPU和内存一定的情况下，采用不同的垃圾回收算法，单位时间内完成的作业肯定是越多越好。
+ 停顿时间：有时候吞吐量高也并不一定就一定就没问题，打个比方，A每天完成1项工作，B一周完成6项工作，确实B更高效，但如果这6项中有很多可以先做完，并且急切需要和别人对接，B在周五才完成这些，那么有些完成了也没必要了，因为影响别人正常工作了。GC也是这样，在高并发环境高负载情况下，如果一次GC时间过长，即使这种GC次数少，但也会对正常业务产生很大影响的，因为GC时，应用程序基本会被暂停的，这时候就无法处理业务请求了，所以停顿时间也是衡量垃圾回收器性能的一个很重要的指标。
+ 垃圾回收频率：指垃圾回收器多久运行一次，如果频率过高，即使每次停顿时间很短，但这种切换过于频繁也会对服务的吞吐量有很大影响。
+ 反应时间：当一个对象被标记为垃圾后，占据的内存空间多久会被释放。

### JVM垃圾回收器分类
几种主流的垃圾回收器
1. 串行收集器
单线程，独占式地进行垃圾回收作业。新生代采用**复制算法**，老年代采用**标记整理算法**。没有线程切换开销。
2. 并行收集器
并行化作业，独占式作业。回收策略和算法同串行一致，不同的只是多线程操作，产生的停顿时间会低于串行。
3. Parallel Scavenge收集器
该收集器使用复制算法，关注点为吞吐量，并且提供了很多参数供开发人员去配置，找到合适的停顿时间或者最大的吞吐量，因为不同的业务对内存，CPU，带宽等的需要是不同的，GC中需要关注的点也不同，所以需要手工配置找到平衡点。
4. CMS（concurrent mark sweep）收集器
CMS以获取最短回收停顿时间会目标，实现了垃圾收集线程和用户线程同时工作。整个过程分为几个阶段：
初始阶段：暂停所有其他线程，并记录下可达对象
并发标记：开启GC线程和用户线程，去标记可达对象
重新标记：停止用户线程，重新标记那些在并发标记阶段变化的对象
并发清除：开启用户线程，开启清除作业
并发重置：该阶段会重新初始化CMS的数据结构，为下一次GC做准备。
从这个阶段可以看出，在GC时用户线程也并不是一直被停顿的了，但由于采用的是标记清除算法，所以最终会有空间碎片。并且在并发阶段，GC线程会占用CPU，所以用户线程的吞吐量会较低。
5. G1（Garbage First）收集器
满足低GC停顿时间的同时，满足高吞吐量的要求。主要面对配置高端的服务器。
主要特征有：

>并行与并发：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。
分代收集：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。
空间整合：与 CMS 的“标记--清理”算法不同，G1 从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。
可预测的停顿：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。

>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 GF 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。
from https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.md
