### Java中的类加载机制

#### 1.类加载器的树状结构
![alt](http://zelcyan.cn/pic/getpic/ODY= )


**引导类加载器**：加载Java核心库（JVM，原生代码实现，不继承java.lang.ClassLoader）
**扩展类加载器**：加载Java扩展库
**系统类加载器**：加载Java应用的类（Classpath），可由ClassLoader.getSystemClassLoader()获取。
开发者可以继承java.lang.ClassLoader类实现自己的类加载器，满足自定义加载类的需求。
需要注意的是，上述类加载器并非采用Java继承的方式实现了父子树形结构关系，而是每个Java类都维护着一个指向定义他的类加载器的引用。
JVM如何判断两个类是不是同一个类：
类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即便是同样的字节代码，被不同的类加载器加载之后所得到的类，也是不同的。如果让这两个类互相赋值，会抛出ClassCastException。
#### 2.类加载器的代理模式以及加载类的过程
类加载器在尝试自己去查找某个类的字节代码并定义（决定了谁是这个类的定义加载器，定义加载器是区分两个类的加载器是否相同的基准）他时，会先代理给父类加载器，由父类加载器尝试去加载这个类，以此类推。代码如下（JDK1.8）
![alt](http://zelcyan.cn/pic/getpic/ODc= )

每个类在被加载之前，先检查这个类有没有被加载过，有则直接返回Class类的实例——这个类。否则，先由父类加载器去加载（c = parent.loadClass(name, false);可以体现），如果父类加载器不能代理这个类（比如对于java扩展类代码，引导类加载器不能执行加载过程，因为引导类加载器只能加载Java核心库的代码），则会抛出ClassNotFoundException，这个异常被本加载器捕获，但不做任何处理，表明其知道父类加载器无法加载（包括父类加载器的父类加载器也无法加载），所以本加载器要自己来定义这个类,去执行findClass()方法。
由于类加载器会首先代理给其他类加载器来尝试加载某个类，所以可能会造成完成某各类的加载工作的类加载器和 启动这个类的加载过程的类加载器并不是同一个。完成类加载工作是通过调用defineClass完成的（这个方法是真正读取字节代码的过程），称为定义加载器，而启动类的加载过程的工作是调用loadClass方法来实现的，这个方法一般是在当前加载器或者字加载器中完成的，称为初始加载器。因为真正重要的是类的定义加载器（读取字节码的能力体现）。
类加载器在成功加载某个类后，会把这个得到的java.lang.Class类的实例缓存起来，下次再请求该类时，会直接使用。（但如果后续代码中再也不需要使用，则会将方法区/元空间中的类卸载掉）

#### 3.线程上下文类加载器
线程上下文类加载器是从JDK1.2开始导入的。如Thread类中的方法getContextClassLoader()和setContextClassLoader(ClassLoader c1)用于获取和设置线程的上下文加载器。如果没有设置，则线程将继承其父线程的上下文加载器。Java应用运行的初始线程的上下文类加载器是系统类加载器——AppClassLoader。在线程中运行的代码可以通过此类加载器来加载类和资源。
想象一种场景：Java提供了很多的服务提供者接口（Service Provider Interface，SPI），允许第三方为这些接口提供实现。比如JDBC等，这些SPI接口必然由Java核心库提供，即引导类加载器加载。但一般第三方提供的实现SPI接口的实现类代码只能由系统类加载器来加载。引导类加载器无法找到JDBC具体实现类，因为引导类加载器只能加载Java核心库，当然引导类加载器更不能代理给系统类加载器。所以代理模式无法解决此类问题。
线程上下文类加载器应运而生。如果不做任何设置，Java应用的现成的上下文类加载器是系统类上下文类加载器，而只需要在SPI接口中的代码使用线程上下文加载器，就可以成功加载到SPI的实现类。


***TCCL在tomcat中的应用***
tomcat Common类加载器 加载Common目录下的类库

tomcat Server类加载器 加载Server目录下的类库
tomcat Shared类加载器 加载Shared目录下的类库
（WebApp类加载器（加载每个WebApp WEB-INF下的类库） - JSP类加载器）

原则：双亲委派机制：先让父类加载器加载，加载失败则尝试自己加载

子类加载器可以使用父类加载器加载的类，父类加载器不可以使用子类加载器的类

因此：如果把Spring类库放在Common中，供若干个WebApp使用的话，纯粹依赖双亲委派，
Spring是无法管理放置在WEB-INF下的代码的，所以此时可以使用TCCL（Thread Context ClassLoader）来加载WEB-INF中的代码

