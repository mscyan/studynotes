## 浅谈操作系统中的IO

*今天看到美团技术博客中的一篇关于Java NIO的博客，于是打算回过头来重新梳理一下IO方面的知识。*
*IO对我们来说再熟悉不过了，IO即Input/Output，我们经常遇到的IO通常有几种含义，一种是输入输出的动作，比如拷贝文件，一种是IO设备，或者叫IO模块。IO是操作系统中的重要组成部分之一，是冯诺依曼体系结构的计算机中不可缺少的部分，数据从输入设备中获取，送到处理器中运算后，再将结果输出到输出设备中，这就完成了一次处理过程*

#### IO设备
讲IO设备时，有必要讲一下总线（Bus）。处理器和主存，处理器和IO设备之间的信息交换都是通过总线进行的，这些总线上会输送数据、地址、控制信号，总线的速度与处理器匹配。

每一个外部设备都包含两个部分，IO模块和设备本身，IO模块与处理器直接打交道，IO模块控制着外部设备，并且管理设备与处理器的所有的数据交换。IO模块中设置有**寄存器**，用于存放控制信息、状态信息和需要交换的数据。
IO模块传输数据的技术有三种：
+ 可编程IO
当处理器需要执行一个IO任务时，它需要给IO模块发送命令，IO模块执行请求，启动外部设备并告诉外部设备需要做什么，并设置IO状态寄存器中相应的位。如果是输出，处理器将主存（即主存储器，RAM，内存，以下所有的主存都代表这个含义）中的数据送到IO模块的寄存器，然后*轮询*检测IO模块中的状态检测寄存器，确认外部设备是否完成操作。如果是输入，处理器则先*轮询*状态检测寄存器，确认外部设备是否将数据准备好，之后再将准备好的数据送到主存。
+ 中断IO
可编程IO确实可以完成任务，但外部设备的执行速度相比于CPU来说时很慢的，CPU通常需要等待很长时间。*轮询*也会降低CPU的利用率。因此中断IO方式中，处理器发送IO指令后，继续做其他的工作，并不执行轮询，当外部设备处理好该做的任务后，IO模块向CPU发送请求服务的信号，之后CPU停止手头的工作，来处理IO任务。中断驱动IO提高了CPU的利用率，整体上也提高了系统的性能。
+ DMA
尽管中断IO提高了CPU利用率，但数据传输的任务仍然需要CPU来处理，当移动大量数据时，我们需要更有效的方式：DMA（Direct Memory Access）。当CPU需要处理IO任务时，给DMA模块发送指令，之后CPU就可以去做其他事情了。DMA模块接收指令后，负责独立传输数据，当任务完成后，DMA模块向CPU发送中断请求。这样又提高了CPU的利用率。***但要注意的是，数据传输始终是走总线的，数据传输过程中，CPU如果需要传输其他数据时，就需要等待DMA模块***，这会影响到CPU的利用率，但对于大数据量的IO操作，DMA比中断IO和可编程IO更有效。

#### 操作系统中的IO模型
对IO模块传输数据的方式有了一定的了解之后，我们就可以深入了解操作系统中的几种IO模型了。这里需要注意，上面说的几种IO的技术是IO模块可能使用的技术，下面涉及到的是操作系统层面的几种IO模型，操作系统以系统调用的方式为我们提供了很多接口，不同的接口使用的IO技术可能是不一样的，针对不同的场景，不同的语言和编程模式会使用不同的IO技术，这都是为了最大化利用硬件资源。

另外，Java小伙伴需要注意，这里讲的也不是Java中的IO有关的API，而是Linux（Unix）系统层面的IO模型。

另外，结合上面对IO模块可能使用的技术的理解，我们知道对CPU来说一次IO分为两个过程，以读操作为例，第一个过程数据要先被准备好放入IO模块中，然后CPU会被中断或轮询 得知数据被准备好，第二个过程再拷贝数据；但操作系统层面与这个有一定区别，操作系统对数据的拷贝也是分为两步，第一步将数据发送到IO模块，之后再拷贝到内核中的某个缓冲区中；第二步将数据拷贝到用户态的进程中。

1. 阻塞IO
阻塞IO按字面意思理解，线程执行IO操作时会被阻塞，第一步和第二步执行完毕之后，线程才会被唤醒，在这两个阶段，线程始终是被阻塞的，因此称为阻塞IO；
2. 非阻塞IO
非阻塞IO听起来非常高级，我们不用阻塞了！那效率肯定杠杠的。但事实并不是这样。当用户进程发起IO系统调用后，内核会直接返回一个error，用户进程接到响应，会继续调用（recvfrom），直到内核将数据拷贝完成之后，会向用户进程返回成功的指示，看起来进程确实没有被阻塞，但它需要一直轮询，这其实也是比较耗费CPU时间的。
3. IO复用
IO复用将IO的两个阶段都考虑进来了，用户进程发出IO请求后，会不断地发送select系统调用，检查数据是否被准备好并拷贝到内核中，如果有，进程再进行下一步的操作。这样有什么好处？单线程可以管理多个连接了，我们可以使用一个线程轮询多个连接，当有一个或者多个连接就绪时，这个线程就可以发送recvfrom调用，让内核给自己发数据，或者不发数据，这样避免了建立太多线程去应对多个连接的操作，因为尽管线程比进程粒度更小，更轻，但建立太多线程对分时系统来说，上下文切换的时间，包括内存的占用都会对系统的性能有很大的影响。
4. 信号驱动IO
与非阻塞IO相比，信号驱动IO的第一个阶段也是不会被阻塞的，并且它不需要轮询，可以做其他的事情，一旦数据被准备好，内核会发送信号给用户进程，进程再通过recvfrom系统调用去获取数据。
5. 异步IO
异步IO在整个IO作业中，用户进程都不会被阻塞，它可以去做其他的事情，数据的准备和数据的拷贝工作完成之后，内核会发送信号去通知进程。

上面的几种IO模型并不好完全理解，比如操作系统对IO操作的两阶段划分，内核到用户进程的数据拷贝，都不好理解，另外并不是说非阻塞IO就一定比阻塞IO效率高，IO复用就比阻塞IO更好用，不同的模型针对了不同的应用场景，比如针对大量连接，IO复用有很高的效率（redis），但如果是少量连接，IO复用可能会用较大的延迟。另外，这些IO模型都是从**进程的角度**来讨论的，如果从CPU的角度分析，又会有不同的划分，比如数据从IO模块传输到内核，内核传输到用户空间，这些过程又会有区别。