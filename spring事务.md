---
title: '事务的隔离级别以及Spring中事务的传播行为'
output: pdf_document
---

*spring为持久层提供了事务支持，并提供了事务传播行为以及隔离级别等操作*

***事务的四大特性***：原子性-a、一致性-c、隔离性-i、持久性-d（即ACID）


#### 传统事务的隔离级别
##### spring中事务可能会产生的各种问题
+ **脏写** ：脏写是指A事务写的数据被B事务写覆盖了，好像自己的操作完全没发生过一样，因此称为脏写
+ **脏读** ：脏读指A事务读到了B事务尚未提交的数据，但倘若B事务在A事务读取完之后Rollback，那么A事务读到的数据是无意义的，这被叫做脏读
+ **不可重复读** ： 如果A事务在一次会话中，由于B事务也在同时执行，多次的读操作对同一条记录读到的数据结果不同，这种现象被叫做不可重复读，B事务执行的操作一般为update
+ **幻读** ： 如果A事务在一次会话中，B事务同时在执行insert操作，这样A事务的第n次操作可能会和n-1次操作的结果不同，即多读到了数据，这被叫做幻读，幻读一般由于B事务执行的insert操作所影响
***以上问题可依次通过提高数据库的隔离级别来逐级避免，脏写是个例外，不论如何不会允许脏写的发生***

##### 事务的隔离级别
+ **READ_UNCOMMITED** 即读未提交，会导致脏读的现象发生，前面说到，脏读是由于读到了B事务未提交的数据，那么其之下的不可重复读和幻读更是可能会发生。
+ **READ_COMMITED** 读已提交，避免了脏读的现象，但同时还是会发生不可重复读的问题。
+ **REPEATABLE_READ** 可重复读，解决了不可重复读。
+ **SERIALIZABLE** 串行化，解决了所有问题，但不建议。
***以上事务的隔离级别由上往下安全性递增，但是会使得服务的效率下降，比如串行化隔离级别会事务依次执行，在高并发中，服务的效率会非常低，这种方式即性能换安全***

并发事务和隔离级别的具体影响关系如下：

|隔离级别|脏读|不可重复读|幻读|
|:--:|:--:|:---|:--:|
|__READ_UNCOMMITED__|possible|possible|possible|
|__READ_COMMITED__  |impossible|possible|possible|
|__REPEATABLE_READ__|impossible|impossible|possible|
|__SERIALIZABLE__   |impossible|impossible|impossible|

##### 事务的传播行为
事务的传播行为特别在spring中被声明，TransactionDefinition接口中规定了7中类型的事务传播行为。事务传播行为是springframework独有的事务增强特性，与数据库无关。笼统的描述，就是**某一个事务发生时被嵌套进了另一个事务时，事务如何传播**

现有事务方法A和事务方法B，A调用B，此时对B执行不同的传播行为的定义，会产生不同的结果：

+ 1.propagation.REQUIRED ：外围方法无事务时，内部的各个事务会互相独立，互不干扰。外围方法有事务包围时，内部的事务会加入到外围事务的方法中，内部回滚，整个事务都会Rollback。如果没有外部事务，则创建新的事务。

+ 2.propagation.REQUIRES_NEW ：外围方法无事务时，内部的各个事务相互独立，互不干扰。外围方法有事务包围时，先挂起外围的事务并创建新事务，等待内部事务执行完成之后再恢复外部事务。

+ 3.propagation.NESTED ：内部事务会被视为子事务，底层实现为savepoint，外部事务的提交会连带着commit内部事务，若rollback也会全部回滚。

+ 4.propagation.SUPPORTS ：如果存在外部事务，则依托外部事务运行，否则非事务地运作。

+ 5.propagation.NOT_SUPPORT ： 必须非事务地运行，如果存在外部事务，则挂起当前事务并运行，运行完成之后再恢复外部事务（需要使用JtaTransactionManager作为事务管理器）

+ 6.propagation.NEVER ：不允许嵌套在事务中，并且自身会非事务地运作，如果被嵌套在事务中，则抛出异常

+ 7.propagation.MANDATORY ：内部事务被配置为该项时，则必须工作在一个外部事务方法中，否则会抛出异常，即该事务必须在已存在的事务支持下运行。

